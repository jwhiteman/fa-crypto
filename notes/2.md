- block ciphers (let's say aes) need 16 byte blocks. they'll pad the last block
  using pkcs7 to get it to 16 bytes.

# TLDR
- need an oracle for all of these: a means of encrypting your attack bytes AND
  then having the app decrypt them; two of these involve mutating
  the ciphertext.
- ECB: byte-at-a-time attack so you can read pre-pended text
- ECB: cut-and-paste attack, so that you can create some franken ciphertext
  to be decrypted in a way that is favorable to you, the attacker
- CBC: bitflip attack: bypass a filter by mutating the ciphertext - eg
  xor'ing some char(s) in the first isolated block of your attack chars
  so that the subsequent block gets the same mutation at the same indexes (e.g
  turning "<" into "="


# ECB

1. you want a fucking oracle. if you just have some ECB ciphertext - unless it's
   long enough to have duplicate 16-byte blocks (unlikely, right?), you won't
   be able to detect it, let alone crack it.
2. there are two big things you can do with ECB to crack it, provided you have an oracle:
   1. crack it a byte at a time
   2. cut and paste.

## cracking a byte at a time: "save & detect"
- if you have an oracle that is appending some text to it, you can read /that/ - the appended text
- you give the oracle 15 bytes of Z, let's say, and then it will be filled with the first byte of the appended text.
- that's the save block
- then create 256 blocks all starting with 15 bytes of Z, and see what matches the save block
- now you've got the first character

assume 4 byte blocks:
```
XXXA|BCD|EFG0
```

note that if you had AB & C, then D would be isolated. The trick to get the
later bytes is that you need all the bytes to the left of it. No matter what
block or byte you're trying to get, it's always a byte at a time.

you can also accomplish this if there is prepended text - you need to take
steps to figure out the number of topoff bytes (i.e the number of bytes you
need to get a clean block for your 15 bytes of Z) along with the number
of prepend blocks, so you can skip them

## cracking via cut-and-paste

use case: there is an oracle with maybe some prepend and append text, along
with some sort of filter (e.g removing certain chars). You can imagine
a cooke with an admin flag, potentially delimited on both sides with ";".
Let's say "=" and ";" are filter so that you can't just add them.

if you put

```
"admin" + "\v" * 11
```

into the oracle, for example, you could get an encrypted final block
with admin (assuming you finagle the input to get that block by itself).
if the last block had "role=user" and your input put "user" as the final
bytes of the last block - you could cut that last block off and paste in
your admin block.

# CBC

Same thing. you can't crack CBC ciphertext, nor crack the key - at least
not with the techniques shown here. So you need an oracle. What you can do,
though is mutate various characters - this could be useful to bypass certain
filters (maybe a cookie, again).

bytes I control:

```
XXXXXXXXXXXXXXXX role<admin:aaaaa
```

If I can find the XXXs block in the ciphertext, I can xor that char with 1
and the byte with the same index in the next block with also get xor'd by 1,
assuming I feed the altered ciphertext back to the application somehow,
to be decrypted. This would turn "<" into "=", and ":" into ";", getting
around the bypass. Pretty cool.

NOTE: IF YOU NEED TO "ADD" or "SUBTRACT" A BYTE, USE XOR NOT FUCKING ADDITION OR SUBTRACTION.

```
irb(main):002:0> 58.to_s(2)
=> "111010"
irb(main):003:0> (58 ^ 1).to_s(2)
```
=> "111011"
